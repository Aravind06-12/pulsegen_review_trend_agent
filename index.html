<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulsegen Trend Analysis Agent | Swiggy/Zomato</title>
    <style>
        :root {
            --primary: #fc8019; /* Swiggy Orange-ish */
            --primary-dark: #d36b15;
            --secondary: #cb202d; /* Zomato Red-ish */
            --bg-body: #f4f6f8;
            --bg-card: #ffffff;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --success: #10b981;
            --highlight: #e0f2fe;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: var(--font-family);
            background-color: var(--bg-body);
            color: var(--text-main);
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Layout */
        header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .brand {
            font-weight: 800;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .brand span { color: var(--primary); }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        aside {
            width: 300px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-y: auto;
        }

        main {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Controls */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-muted);
        }

        select, input, button {
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        button {
            background-color: var(--text-main);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #000;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* Agent Log Console */
        .agent-console {
            background: #111827;
            color: #10b981;
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.75rem;
            height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* New messages at bottom visually, but scrolled */
        }
        
        .log-entry { margin-bottom: 4px; }
        .log-time { color: #6b7280; margin-right: 8px; }
        .log-info { color: #60a5fa; }
        .log-warn { color: #f59e0b; }

        /* Reports Area */
        .card {
            background: var(--bg-card);
            border-radius: 8px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-title {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .table-container {
            overflow-x: auto;
            flex: 1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            text-align: left;
        }

        th, td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }

        th {
            background-color: #f9fafb;
            font-weight: 600;
            color: var(--text-muted);
            position: sticky;
            left: 0;
            z-index: 10;
        }
        
        /* Sticky first column for topic names */
        td:first-child, th:first-child {
            position: sticky;
            left: 0;
            background-color: var(--bg-card);
            z-index: 20;
            border-right: 1px solid var(--border);
            font-weight: 600;
            min-width: 220px;
        }

        tr:hover td {
            background-color: var(--highlight);
        }

        /* Heatmap style cells */
        .cell-freq {
            text-align: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        /* Dynamic coloring for intensity */
        .heat-low { color: var(--text-main); }
        .heat-med { color: var(--primary); font-weight: bold; }
        .heat-high { color: var(--secondary); font-weight: 800; background-color: #fef2f2; }

        /* Status Badge */
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        .badge-new { background: #dbeafe; color: #1e40af; }
        .badge-seed { background: #f3f4f6; color: #374151; }

        /* Chart Area */
        .chart-wrapper {
            padding: 1rem;
            height: 250px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        
        .chart-bar-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            height: 100%;
            gap: 2px;
        }
        
        .bar {
            background: var(--primary);
            opacity: 0.7;
            border-radius: 2px 2px 0 0;
            transition: height 0.5s ease;
            min-height: 2px;
        }
        
        .bar:hover { opacity: 1; }
        
        .bar-label {
            text-align: center;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 4px;
            transform: rotate(-45deg);
            transform-origin: center;
        }

        /* Loader */
        .loader-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

<header>
    <div class="brand">
        <span>⚡</span> Pulsegen Trend Agent
    </div>
    <div style="font-size: 0.85rem; color: var(--text-muted);">
        Senior AI Engineer Assignment
    </div>
</header>

<div class="main-container">
    <aside>
        <div class="control-group">
            <label for="appSelect">Target App</label>
            <select id="appSelect">
                <option value="swiggy">Swiggy</option>
                <option value="zomato">Zomato</option>
            </select>
        </div>

        <div class="control-group">
            <label for="dateSelect">Target Date (T)</label>
            <input type="date" id="dateSelect">
        </div>

        <button id="runBtn">Run Agent Analysis</button>

        <div style="margin-top: 1rem;">
            <label>Agent Logs</label>
            <div class="agent-console" id="agentConsole">
                <!-- Logs appear here -->
                <div class="log-entry"><span class="log-time">System:</span> Ready to ingest data.</div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Agent Capabilities</label>
            <ul style="font-size: 0.8rem; color: var(--text-muted); padding-left: 1.2rem;">
                <li>Batch Ingestion (Daily)</li>
                <li>Semantic Deduplication</li>
                <li>Taxonomy Clustering</li>
                <li>New Topic Discovery</li>
            </ul>
        </div>
    </aside>

    <main>
        <!-- Stats / Top Chart -->
        <section class="card" style="flex: 0 0 auto;">
            <div class="card-header">
                <span class="card-title">Volume Trend: Top 3 Issues</span>
                <div id="chartLegend" style="font-size: 0.8rem;"></div>
            </div>
            <div class="chart-wrapper" id="trendChart">
                <!-- JS will render bars here -->
                <div style="margin: auto; color: var(--text-muted);">Run analysis to see chart</div>
            </div>
        </section>

        <!-- Main Report Table -->
        <section class="card" style="flex: 1; min-height: 400px;">
            <div class="card-header">
                <span class="card-title">Detailed Trend Report (Frequency)</span>
                <div>
                    <span class="badge badge-seed">Seed Topic</span>
                    <span class="badge badge-new">Evolving Topic</span>
                </div>
            </div>
            <div class="table-container">
                <table id="reportTable">
                    <thead>
                        <tr id="tableHeader">
                            <th>Topic</th>
                            <!-- Dates go here -->
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Rows go here -->
                    </tbody>
                </table>
            </div>
        </section>
    </main>
</div>

<div class="loader-overlay" id="loader">
    <div class="spinner"></div>
    <div style="font-weight: 600;">Processing Batches...</div>
    <div style="font-size: 0.85rem; color: var(--text-muted);">Agent is clustering topics</div>
</div>

<script>
/**
 * PULSEGEN TREND AGENT
 * --------------------
 * A frontend simulation of an Agentic AI system.
 * It mocks data ingestion, applies heuristic clustering for deduplication,
 * and generates the required matrix report.
 */

// --- Configuration & State ---
const CONFIG = {
    lookbackDays: 30,
    batchSize: 20, // Simulated reviews per day
    seedTopics: [
        "Delivery issue", 
        "Food stale", 
        "Delivery partner rude", 
        "Maps not working properly", 
        "Instamart should be open all night", 
        "Bring back 10 minute bolt delivery"
    ]
};

// Taxonomy/Synonym Knowledge Base
// This simulates the "Ontology" required to solve the deduplication challenge.
const TAXONOMY = {
    "Delivery issue": ["late", "delay", "waiting too long", "time taken", "slow delivery", "not arrived"],
    "Food stale": ["cold", "soggy", "rotten", "smelled bad", "old food", "tasteless", "bland"],
    "Delivery partner rude": ["rude", "impolite", "misbehaved", "bad behavior", "shouted", "argued", "abusive"],
    "Maps not working properly": ["location wrong", "gps", "navigation", "map error", "wrong address shown"],
    "Instamart should be open all night": ["instamart night", "24/7", "close early", "need groceries late"],
    "Bring back 10 minute bolt delivery": ["bolt", "10 min", "fast delivery removed", "want express"]
};

const STATE = {
    app: 'swiggy',
    date: null,
    data: {}, // Keyed by 'YYYY-MM-DD'
    clusteredTopics: new Set(),
    topicMatrix: {} // { "Topic Name": { "2024-06-01": 5, ... } }
};

// --- Mock Data Generation ---
// Since we cannot scrape the live Play Store in a browser without CORS/Backend,
// we generate realistic data based on the prompt's examples.

const VERBS = ["is", "was", "are", "were"];
const ADJECTIVES = ["very", "extremely", "really", "slightly"];

function getRandomItem(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function generateDailyReviews(dateStr, app) {
    const reviews = [];
    // 1. Seed Topic Reviews (High Probability)
    CONFIG.seedTopics.forEach(topic => {
        // Add 1-3 variations of this topic
        const count = Math.floor(Math.random() * 3) + 1;
        for(let i=0; i<count; i++) {
            reviews.push(generatePhraseForTopic(topic));
        }
    });

    // 2. Random Noise / Generic Reviews
    const noiseCount = Math.floor(Math.random() * 5);
    for(let i=0; i<noiseCount; i++) {
        const noises = ["good app", "bad ui", "great service", "unable to login", "payment failed", "coupon not working"];
        reviews.push(getRandomItem(noises));
    }

    // 3. Evolving Topics (Simulate "New Issues" appearing in the last 10 days)
    const dateObj = new Date(dateStr);
    const endDate = new Date(); // Today
    const daysDiff = (endDate - dateObj) / (1000 * 60 * 60 * 24);

    if (daysDiff < 10) {
        // Introduce a new topic e.g., "UI update is bad"
        if (Math.random() > 0.7) {
            reviews.push("The new UI update is terrible");
            reviews.push("Can't find anything after update");
        }
        // Introduce "Refund pending"
        if (Math.random() > 0.6) {
            reviews.push("Refund is pending for days");
            reviews.push("Money not deducted yet");
        }
    }

    return reviews;
}

function generatePhraseForTopic(topic) {
    // This function creates variations to test the Deduplication Agent
    switch(topic) {
        case "Delivery partner rude":
            return getRandomItem([
                "Delivery guy was rude",
                "Delivery partner behaved badly",
                "Delivery person was impolite",
                "The agent misbehaved with me"
            ]);
        case "Food stale":
            return getRandomItem([
                "Food was cold",
                "Biryani was soggy",
                "The curry smelled rotten",
                "Pizza was stale"
            ]);
        case "Delivery issue":
            return getRandomItem([
                "Order arrived very late",
                "Delivery took 1 hour",
                "Package was open",
                "Delay in delivery"
            ]);
        case "Instamart should be open all night":
            return getRandomItem([
                "Instamart closed too early",
                "Need Instamart 24/7",
                "Why is instamart not open at night?"
            ]);
        default:
            return topic;
    }
}

// --- The Agentic Logic (The "AI") ---

class Agent {
    constructor() {
        console.log("Agent initialized.");
    }

    log(msg, type="info") {
        const consoleEl = document.getElementById('agentConsole');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString().split(' ')[0];
        
        let colorClass = "";
        if(type === "warn") colorClass = "log-warn";
        else if(type === "info") colorClass = "log-info";

        entry.innerHTML = `<span class="log-time">${time}</span> <span class="${colorClass}">${msg}</span>`;
        consoleEl.prepend(entry); // Add to top
    }

    // 1. Ingestion Phase
    ingestData(app, endDate) {
        this.log(`Starting ingestion for ${app.toUpperCase()}...`);
        STATE.data = {};
        const end = new Date(endDate);
        
        for (let i = 0; i < CONFIG.lookbackDays; i++) {
            const d = new Date(end);
            d.setDate(d.getDate() - i);
            const dateStr = d.toISOString().split('T')[0];
            
            // Generate Batch
            const reviews = generateDailyReviews(dateStr, app);
            STATE.data[dateStr] = reviews;
            
            if (i % 5 === 0) this.log(`Batch [${dateStr}]: Ingested ${reviews.length} reviews.`);
        }
        this.log("Ingestion complete.");
    }

    // 2. Processing & Deduplication Phase
    // Challenge: "Delivery guy was rude" and "Delivery partner impolite" must match.
    processAndCluster() {
        this.log("Starting Heuristic Clustering Engine...", "info");
        STATE.topicMatrix = {};
        STATE.clusteredTopics.clear();

        // Initialize Matrix with Seeds
        CONFIG.seedTopics.forEach(topic => {
            STATE.topicMatrix[topic] = {};
            STATE.clusteredTopics.add(topic);
        });

        const sortedDates = Object.keys(STATE.data).sort(); // Ascending order (Oldest -> Newest)

        sortedDates.forEach(date => {
            const reviews = STATE.data[date];
            
            reviews.forEach(reviewText => {
                const normalizedText = reviewText.toLowerCase().trim();
                let assignedTopic = null;

                // Step A: Check against Taxonomy (High Recall)
                // We iterate through known taxonomies to see if keywords match
                for (const [topic, keywords] of Object.entries(TAXONOMY)) {
                    const match = keywords.some(kw => normalizedText.includes(kw));
                    if (match) {
                        assignedTopic = topic;
                        break;
                    }
                }

                // Step B: Topic Discovery (Evolving Topics)
                // If no taxonomy match, check if it's a variation of a recently "discovered" topic
                // or if it's a brand new high-frequency cluster.
                // For this simulation, we use simple string matching against unclustered frequent phrases.
                
                if (!assignedTopic) {
                    // Simple logic: If we've seen this phrase before recently, create/use a generic bucket
                    // In a real app, this would use Embeddings.
                    
                    // Mock Logic: Detect specific new trends based on keywords not in seed
                    if (normalizedText.includes("ui") || normalizedText.includes("update")) {
                        assignedTopic = "New UI/UX issues";
                    } else if (normalizedText.includes("refund") || normalizedText.includes("money")) {
                        assignedTopic = "Payment/Refund issues";
                    }
                }

                // Step C: Fallback
                if (!assignedTopic) {
                    assignedTopic = "Other / Generic";
                }

                // Ensure topic exists in Matrix
                if (!STATE.topicMatrix[assignedTopic]) {
                    STATE.topicMatrix[assignedTopic] = {};
                    this.log(`Discovered evolving topic: "${assignedTopic}"`, "warn");
                }

                // Update Count
                STATE.topicMatrix[assignedTopic][date] = (STATE.topicMatrix[assignedTopic][date] || 0) + 1;
            });

            // Fill 0 for dates with no mentions for existing topics
            Object.keys(STATE.topicMatrix).forEach(topic => {
                if (!STATE.topicMatrix[topic][date]) {
                    STATE.topicMatrix[topic][date] = 0;
                }
            });
        });

        this.log("Clustering complete. Report generated.");
    }
}

// --- UI Controller ---

function init() {
    // Set default date to today
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('dateSelect').value = today;

    document.getElementById('runBtn').addEventListener('click', runAnalysis);
}

async function runAnalysis() {
    const loader = document.getElementById('loader');
    const btn = document.getElementById('runBtn');
    
    loader.style.display = 'flex';
    btn.disabled = true;
    btn.textContent = "Analyzing...";

    const app = document.getElementById('appSelect').value;
    const date = document.getElementById('dateSelect').value;

    // Simulate async processing time for "Agent" feel
    const agent = new Agent();
    
    setTimeout(() => {
        agent.ingestData(app, date);
        
        setTimeout(() => {
            agent.processAndCluster();
            renderReport(date);
            
            loader.style.display = 'none';
            btn.disabled = false;
            btn.textContent = "Run Agent Analysis";
        }, 800);
    }, 800);
}

function renderReport(endDateStr) {
    // 1. Prepare Data Structure
    // Dates need to be T-30 to T (Oldest to Newest for columns)
    const endDate = new Date(endDateStr);
    const dateColumns = [];
    for(let i=CONFIG.lookbackDays-1; i>=0; i--) {
        const d = new Date(endDate);
        d.setDate(d.getDate() - i);
        dateColumns.push(d.toISOString().split('T')[0]);
    }

    // 2. Render Table Header
    const thead = document.getElementById('tableHeader');
    thead.innerHTML = '<th style="min-width:200px;">Topic</th>'; // Reset
    
    dateColumns.forEach(d => {
        const th = document.createElement('th');
        const dateObj = new Date(d);
        const label = `${dateObj.getMonth()+1}/${dateObj.getDate()}`; // M/D format
        th.textContent = label;
        th.title = d;
        thead.appendChild(th);
    });

    // 3. Render Rows
    const tbody = document.getElementById('tableBody');
    tbody.innerHTML = '';

    // Calculate total volume per topic over the period to sort rows by impact
    const topicTotals = {};
    for(const [topic, dates] of Object.entries(STATE.topicMatrix)) {
        topicTotals[topic] = Object.values(dates).reduce((a,b)=>a+b, 0);
    }

    // Sort: High impact first
    const sortedTopics = Object.keys(STATE.topicMatrix).sort((a,b) => topicTotals[b] - topicTotals[a]);

    sortedTopics.forEach(topic => {
        const tr = document.createElement('tr');
        
        // Topic Name Cell
        const tdTopic = document.createElement('td');
        let badge = '';
        if (CONFIG.seedTopics.includes(topic)) {
            badge = '<span class="badge badge-seed" style="margin-left:8px">Seed</span>';
        } else {
            badge = '<span class="badge badge-new" style="margin-left:8px">New</span>';
        }
        tdTopic.innerHTML = `${topic}${badge}`;
        tr.appendChild(tdTopic);

        // Date Cells
        dateColumns.forEach(date => {
            const td = document.createElement('td');
            const count = STATE.topicMatrix[topic][date] || 0;
            td.className = 'cell-freq';
            td.textContent = count;

            // Simple Heatmap Styling
            if (count === 0) td.style.color = '#e5e7eb';
            else if (count < 5) td.className += ' heat-low';
            else if (count < 10) td.className += ' heat-med';
            else td.className += ' heat-high';

            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });

    // 4. Render Chart (Top 3 Topics)
    renderChart(dateColumns, sortedTopics.slice(0, 3));
}

function renderChart(dates, topTopics) {
    const wrapper = document.getElementById('trendChart');
    wrapper.innerHTML = '';
    
    if (topTopics.length === 0) return;

    const maxVal = Math.max(
        ...topTopics.map(t => dates.map(d => STATE.topicMatrix[t][d] || 0)).flat()
    );

    // We will render 3 lines (represented by side-by-side bars or overlaid)
    // For simplicity in vanilla JS without canvas libraries, let's do stacked bars or grouped bars.
    // Let's do a multi-line chart using SVG paths for best visuals.
    
    // Generate SVG
    const width = wrapper.clientWidth;
    const height = wrapper.clientHeight;
    const padding = 30;
    
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.style.overflow = "visible";

    const colors = ["#fc8019", "#cb202d", "#10b981"];

    // Draw lines
    topTopics.forEach((topic, index) => {
        const color = colors[index % colors.length];
        const points = dates.map((date, i) => {
            const x = padding + (i * (width - 2 * padding) / (dates.length - 1));
            const val = STATE.topicMatrix[topic][date] || 0;
            const y = height - padding - ((val / maxVal) * (height - 2 * padding));
            return `${x},${y}`;
        }).join(" ");

        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", color);
        polyline.setAttribute("stroke-width", "3");
        polyline.setAttribute("points", points);
        
        // Tooltip title
        const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
        title.textContent = topic;
        polyline.appendChild(title);

        svg.appendChild(polyline);
    });

    // Legend
    const legendDiv = document.getElementById('chartLegend');
    legendDiv.innerHTML = topTopics.map((t, i) => 
        `<span style="color:${colors[i]}">● ${t}</span>`
    ).join(" &nbsp;&nbsp; ");

    wrapper.appendChild(svg);
}

// Start
init();

</script>
</body>
</html>